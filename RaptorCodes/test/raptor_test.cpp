/*!
*
* \file   raptor_test.cpp
*
* \brief  Implementation of raptor codes data operation APIs
*
*
* \par    Include files
*         -     
*
* \par    Copyright (c) 2011 Yeqing Wu
*
* This library is free software; you can redistribute it and/or modify it 
* under the terms of the GNU Lesser General Public License as published by 
* the Free Software Foundation. This software is developed by refering to the software wrote by Vicente Sirvent,
* but many parts(especially some critical parts) of the raptor codes in that software have not been implemented 
* and there are lots of bugs and logical errors in that software. So I re-design software and implement it.
*
*
* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
* See the GNU Lesser General Public License for more details.
* You should have received a copy of the GNU Lesser General Public License along with this library; 
* if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
* 
* \version 
* Revision of last commit: $Rev$ 
* Author of last commit  : $Author$ 
* Date of last commit    : $Date$ 
*
*/

#include <stdio.h>

#include <windows.h>

#include "raptor_defines.h"
#include "raptor_triple.h"
#include "raptor_encoder.h"
#include "raptor_decoder.h"

using std::queue;
using std::vector;

#define random(x) (rand() % x)

U32 test_triple_generator(void)
{
  CTripleGenerator gen;
  U32 k = 1024;
  for (U32 x = 0; x < k; ++x)
  {
    CTriple triple = gen.Trip(k, x);
  }

  return 0;
}

queue<CData*> encoder_test(U32 k, U32 dataLen, U32 lossNum)
{
  CEncoder encoder(k, lossNum);

  const U32 DATA_LEN = 1024;
  U8 rndData[DATA_LEN];

  printf("\nSource symbols generated by random:\n");
  U32 index = 0;
  for (U32 i = 0; i < k; ++i)
  {
    for (U32 j = 0; j < dataLen; ++j)
    {
      rndData[j] = rand();
#ifdef TEST_PURPOSE
      index++;
      printf("%6d", rndData[j]);
      if ((index % SHOW_NUMS) == 0)
      {
        printf("\n");
      }
#endif
    }
    CData data(rndData, dataLen);
    encoder.AddData(&data);
  }

  return encoder.encoded_sym;
}

U32 decoder_test(U32 k, queue<CData* > &encoded_sym, U32 N, U32 lossNum, vector<U32> &ESI_vector)
{
  CDecoder decoder(k, N, lossNum, ESI_vector);

  S32 t2 = GetTickCount();
  decoder.Decode(encoded_sym);

  S32 t1 = GetTickCount() - t2;
  printf("Total Decoding Time: %d\n", t1);

  t2 = GetTickCount();

  return 0;
}

S32 compare(const void* a, const void* b)
{
  return (*(S32* )a - *(S32* )b);
}

U32 main(U32 argc, CHAR* argv[])
{
  U32 k;
  U32 dataLen;
  U32 lossNum;
  queue<CData* > encoded_sym;
  
  printf("Input the number of source symbols: ");
  scanf("%d", &k);

  printf("Input the length of every source symbol(be multiples of 2): ");
  scanf("%d", &dataLen);

  printf("Input the loss data number: ");
  scanf("%d", &lossNum);

  printf("--------------------------Encoder-----------------------------\n");
  encoded_sym = encoder_test(k, dataLen, lossNum);

  U32 encodedSymSize = encoded_sym.size();
  printf("\nEncoded Packet Total Numbers: %d\n", encodedSymSize);
  U32* lossDataIndex = new U32[lossNum];
  for (U32 lossIndex = 0; lossIndex < lossNum; ++lossIndex)
  {
    lossDataIndex[lossIndex] = random(encodedSymSize);
  }

  qsort(lossDataIndex, lossNum, sizeof(U32), compare);

  for (U32 lossIndex = 0; lossIndex < lossNum; ++lossIndex)
  {
    printf("Lost Packet Index: %d\n", lossDataIndex[lossIndex]);
  }

  vector<U32> ESI_vector;
  BOOL isFound = false;
  for (U32 i = 0; i < encodedSymSize; ++i)
  {
    isFound = false;
    for (U32 j = 0; j < lossNum; ++j)
    {
      if (i == lossDataIndex[j])
      {
        isFound = true;
        break;    
      }
      else 
      {
        isFound = false;
      }
    }
    if (isFound == false)
    {
      ESI_vector.push_back(i);
    } 
  }

#if 0
  printf("\n");
  U32 encodedSymSize = encoded_sym.size();
  for (U32 i = 0; i < encodedSymSize; ++i)
  {
    printf("After Encoding 2: %d\n", *encoded_sym.front()->GetData());
    encoded_sym.pop();
  }
#endif

  printf("\n\n\n--------------------------Decoder-----------------------------\n");
  U32 receivedSymSize = encoded_sym.size();
  decoder_test(k, encoded_sym, receivedSymSize, lossNum, ESI_vector);

  return 0;
}